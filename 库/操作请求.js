//我们将操作中人类与电脑所一致的部分独立出来做成了操作API
//那么不一致的部分呢？对于人类，需要布置好操作所需的UI接口
//而对于电脑，需要做出能够根据不同情形选择的AI。
//布置UI与AI的这个部分对于人类和电脑其实是一一对应的。这个部分同样做出API——操作请求
//这部分API要注意的是对于人类和电脑是不同的，会对应不同的操作
//当一个结算完成后，会先检查剧情进展，随后提出操作请求。如果有剧情进展则在剧情进展末尾进行操作请求。
//要注意，剧情里这种要求你点击对话框进行推进的部分并不属于操作请求，一些是结算的一部分，另一些由另一个维度来控制。

//尘埃落定操作请求：
////当一个完整的操作结算完成后对当前操作者发起一个操作请求
//一下带星号设定仅供未来设计参考，目前的设计想法是，只有当回合结束，新回合开始，才会进行这些判定
//******************
//尘埃落定操作请求的地位最为特殊，所有的操作最后都会指向尘埃落定操作请求。
//为了避免无休止的插入结算（主要是装备的安装与卸载操作），很多检验结算设计为并不会在结算链中立刻执行，
//而是待到尘埃落定时再重复检查计算
//例如，装备在安装时一些角色的状态会变化，角色权限又会依托于这些状态的变化而修改。角色权限的修改又可能触发一些剧情。
//如果在装备安装或卸载时，角色状态就立即影响角色权限，就可能会触发无止境的链式结算。
//但是在操作链上，装备安装后续还有其他操作要处理，因此这些插入结算会导致很多问题。
//如果能限制角色权限等依托于其他状态数值变化内容的更新时机，当这些结算延后到尘埃落定时一并解决就好了。
//为此，设计了全局的尘埃落定事件映射集，它使用方法与含参事件有一定相似之处，但是结算上有所区别————
//尘埃落定事件映射集由 尘埃落定事件名 : 尘埃落定事件参数集合 组成
//尘埃落定事件参数集合，由一些uid组成。
//每个尘埃落定事件名绑定一个确定的执行体，这个对应关系是由一个尘埃落定结算图鉴决定的。
//这里，对于尘埃落定事件执行体的自由度有所限制，只能输入一个参数，该参数是个uid（也可以没有参数）。
//因此，所谓尘埃落定事件参数集合里的uid，其实不是一个尘埃落定事件的多个参数中的某个，而是多个尘埃落定结算事件中的某个的唯一参数。
//因此尘埃落定事件所能处理的复杂度是有限的，例如只能处理一个角色的某个权限按其他属性变更等等
//不同尘埃落定事件间的排序方式同样由该图鉴决定，而同一个尘埃落定事件内部，不同uid参数谁先结算，也由图鉴内部决定
//当你想添加尘埃落定事件检查时，类似于含参事件分发器，分发一个尘埃落定事件极其对应参数
//分发过程中，检查尘埃落定事件映射集是否有该事件名，若无则创建 事件名 : 集合，然后集合中插入参数uid。
//若有，则直接插入参数uid
//在尘埃落定操作请求时，从所有事件中根据排序关系找出第一个操作的事件，然后再找出第一个执行操作的参数
//进行执行前，将参数移出集合，如果集合在移出后为空，移出整个操作事件。然后执行体运行。
//注意，一次尘埃落定操作请求只会执行一个事件执行体，这个事件执行体在结算完成后会进行下一次尘埃落定操作请求。
//如果尘埃落定事件映射集为空，那么就进入正常的操作请求结算流程。
//下面是正常结算流程
//***************
//这个操作请求包括：鼠标划入地图上的格子时，取消已有的敌可达范围显示，且如果当前格子里有一个敌方，会显示敌方的移动可达范围。
//当鼠标点击地图上的格子时，如果仅有一个可操作对象（角色或场景），将进行一次“决策选定角色”或“决策选定场景”操作
//如果有多个可操作对象，将生成一个对话框来决定具体选择哪个对象，然后进行具体操作（待实装）
//而如果点击没有任何可操作对象的格子，则会弹出全局控制板，可以推进下一回合，查看操作帮助、图鉴等操作。
function 尘埃落定操作请求(控制势力标识){
    let 控制势力 = cls.势力.获取实例(控制势力标识);
    //如果控制势力是玩家
    if (控制势力.玩家性) {
        function 空闲鼠标移至其他格子函数(格子){
            //先取消已有的敌可达范围显示
        }
        全局.UI事件分发器.添加监听("鼠标移至其他格子", 空闲鼠标移至其他格子函数);
    }
}
//隐藏空间
(function(){

//角色大图鉴是一张静态表，包括各个角色类型的角色初始化参数。
//图标：角色图标名数组，其中有该角色可能在游戏中出现的所有图标的图标名。
//初始HP即最大HP，且HP补满。
//某些需要角色残血出场的情况该怎么办？答：创建角色以后再对角色调整。
模组.角色大图鉴 = {
	大雄 : {
		初始权限码 : 5,
		图标 : ["大雄图标", "北诞老人图标"],
		初始图标名 : "北诞老人图标",
		初始主头像名 : "北诞老人头像",
		初始连携头像名 : "黑化的大雄头像",
		初始HP : 9500
	},
	哆啦A梦 : {
		初始权限码 : 5,
		图标 : ["哆啦A梦图标"],
		初始图标名 : "哆啦A梦图标",
		初始主头像名 : "普通的哆啦A梦头像",
		初始连携头像名 : null,
		初始HP : 2000
	}
}

//这是专门用于控制角色在地图上的图标、属性条上的头像等等具体实例的安排事项。
//在存档的时候它们的信息是不会被保存的，只会在加载的时候重新建立。
class 角色UI控制器 {
	constructor(所属角色实例) {
		let that = this;
		that.角色实例 = 所属角色实例;
		//地图图标字典表以 角色图标元件名 : 角色图标元件实例 的键值对构成。
		//通过对图标元件的构造来实现，并不直接修改图标。
		//地图图标字典表里的图标是为地图显示准备的，需要导入地图使用，
		//其他UI条显示的图标在临时图标池内。
		that.地图图标字典表 = {};
		for (let 角色图标元件名 of 模组.角色大图鉴[所属角色实例.角色类型].图标) {
			that.地图图标字典表[角色图标元件名] = new lib[角色图标元件名]();
			that.地图图标字典表[角色图标元件名].visible = 所属角色实例.角色图标显示中;
		}
		//临时图标池以 角色图标元件名 : 角色图标元件实例数组列表 的键值对构成。
		//临时图标池不导入UI条，总是在舞台最顶层。
		//当某个UI条需要某个角色的某个图标时，遍历临时图标池找到一个未显示的图标，移动到对应位置显示
		//如果没有未显示的图标，创建一个。
		//当UI条取消显示时需要将其使用的所有图标的visible置为false
		that.临时图标池 = {};
		for (let 角色图标元件名 of 模组.角色大图鉴[所属角色实例.角色类型].图标) {
			that.临时图标池[角色图标元件名] = [];
		}
	}
}

class 角色 {
	constructor(角色类型) {
		var that = this;
		that.uid = UID.分配(that); //因为存在同名角色，需要一个uid来唯一标识一名角色。
		that.角色类型 = 角色类型;
		//角色权限码描述了角色的身份权限。每一位对应一个身份权限。
		//1：我方角色身份权限
		//2：敌方角色身份权限
		//4：小型角色身份权限
		that.角色权限码 = 模组.角色大图鉴[角色类型].初始权限码;
		that.移动力 = 3,
		that.最大HP值 = 模组.角色大图鉴[角色类型].初始HP;
		that.当前HP值 = that.最大HP值;
		//角色权限着重于描述角色与移动通路间的关系，且一种角色权限是不计数的。
		//对于其他被动装备、特性等所定义的状态，仍然需要其他附加状态来描述
		//为何不直接在角色下附加，而要放在一个“标准扩展状态”呢？
		//主要是为了给扩展mod带一个好头，不同的mod添加的状态可能重复命名
		//希望不同的mod作者为自己设计的道具与状态添加命名空间，所以标准的道具状态就带头设计了一个空间
		that.标准扩展状态 = {
			//特性“军团性”所用到的状态。拥有军团性特性的角色，其内部有多个血条
			//当前HP值是所有军团HP值之和，在HP扣减结算前对军团HP值进行结算
			//军团HP归零时，对应的索引将被splice方法从军团数组中移除。
			//军团HP值的length影响了军团性的其他参数，例如攻击次数，以及在UI上的显示
			//军团性角色的图标中有一个动态文本元素，在军团HP值的length修改时会变更
			军团HP值 : [],
		};
		//当前图标名永不为空。即使当前角色可能不显示在地图上，但却有其他需要显示该角色的图标的情景。
		that.当前图标名 = 模组.角色大图鉴[角色类型].初始图标名;
		//并不使用当前图标名为null来表示当前角色的未显示，而是另外设置字段来表示角色图标是否显示的情况。
		that.角色图标显示中 = false;

		//两个头像名都是字符串，设置参数也是字符串
		that.当前主头像名 = 模组.角色大图鉴[角色类型].初始主头像名;
		that.当前连携头像名 = 模组.角色大图鉴[角色类型].初始连携头像名;

		//对于每个角色都有操作状态，这个操作状态相当重要，不仅影响UI的可用性
		//和计划废用地图操作状态不同，角色的操作状态感觉始终都很重要。
		//更是对各个操作事件是否能够成功触发有着决定性的影响
		//不可操作		不是该角色的回合，该角色没有任何操作权限
		//未移动		角色移动前，可以移动，可以直接使用任何道具，可以整理道具。
		//移动中		角色选择移动后，有两个选项"雷厉风行"或者"移动完了"，这是一个不稳定状态，有第一个撤销时机
		//				如果选择“雷厉风行”，只能使用轻便型道具，不可再移动，不可整理道具，不可使用即时性道具。
		//				雷厉风行如果撤销，将退回至未移动状态。在追加行动中使用道具会得到突袭度加成。
		//				注：传送道具属于整理道具的范畴，也就是说在追加行动中不可以传递道具。
		//				雷厉风行文本说明：移动后未经喘息就立即使用装备开始了行动。由于行动的对象面对刚刚移动的对手没有作出最佳的迎敌姿态，因此会受到加成哦~
		//				请注意！移动中是一个非常不稳定的状态，之所以设置这个状态只是为了预演算雷厉风行比较便利
		//				为了确保角色不会在这个状态的处理中插入其他角色的操作事件，会把该角色放进地图的锁定操作角色属性里。
		//				不过这个锁定操作属性可能不再需要了
		//行动中		这是另一个不稳定状态。当我们对一个目标角色使用道具时，某些道具会引起目标的接敌。
		//				对于这类道具，即使目标接敌之后，我们的行动依然是可以撤销的。
		//				也就是说不论敌方行动还是我方行动，交战按钮都掌握在玩家手里
		//				当然，敌方行动的时候，我们接敌不能撤销。但我方行动的时候，敌方接敌完了，我们还能撤销，这就是区别。
		//				行动中也是个不稳定状态，期间不可插入其他角色的操作事件。
		//				如果不是使用那种需要接敌的道具的话，是不需要进入行动中状态的。用就完了，用完直接已行动。
		//已移动		角色移动后选择“移动完了”，然后再控制角色，不可再移动，可以使用轻便型道具，可以整理道具，可以使用即时性道具。
		//				移动完了文本说明：移动后可以稍微整顿一下再行动哦~不过尽管只是短暂的整顿时间，对手也已经整理好自己的迎敌姿态了。
		//已行动		角色使用操作类道具后，可以整理道具，不能进行其他操作。
		that.操作状态 = "不可操作";

		//是否要考虑多格角色？我的答案是宁愿将多格角色视作多个单格角色的组合
		//当前所在格信息需要角色导入地图以后才填充
		//角色原则上只可能存在一个地图内，
		//如果有一个角色因某些原因出现在多个格子多个地图，应该为出现在其他格子额外创建角色
		that.当前所在格uid = 0;
		//角色的道具列表都是按顺序排放的，因此用数组列表，而非集合
		that.持有装备uid列表 = [];
		that.穿戴装备uid列表 = [];
		that.特殊装备uid列表 = [];
		that.备给道具uid列表 = [];
		that.候补道具uid = 0;
	}
	get 当前所在格() {
		return UID.获取实例(this.当前所在格uid);
	}
	当前角色头像名设置(主头像名, 连携头像名) {
		let that = this;
		that.当前主头像名 = 主头像名;
		that.当前连携头像名 = 连携头像名;
	}
	get UI控制器() {
		return 角色.角色uid与角色UI控制器映射集.get(this.uid);
	}
	//图标切换、显示管的都是UI控制器中地图图标字典表内的图标，临时图标不在其管理范围内。
	地图图标切换(图标名) {
		let that = this;
		if (!that.UI控制器.地图图标字典表.hasOwnProperty(图标名)) {
			//不能切换一个不存在的图标名
			return;
		}
		let 新图标 = that.UI控制器.地图图标字典表[图标名];
		//角色自初始化以来就存在当前图标名，当前图标名绝不可能为空
		let 旧图标 = that.UI控制器.地图图标字典表[that.当前图标名];
		旧图标.visible = false;
		//一直以来只有当前图标会随着角色所在格子改变而更新像素位置，
		//新切换上来的图标的像素位置也要与旧图标像素位置同步
		新图标.set({ x: 旧图标.x, y: 旧图标.y });
		that.当前图标名 = 图标名;
		if (that.角色图标显示中) {
			新图标.visible = true;
		}
	}
	地图图标显示(开关 = true) {
		let that = this;
		that.角色图标显示中 = 开关;
		if (that.当前图标名 != null) {
			that.UI控制器.地图图标字典表[that.当前图标名].visible = that.角色图标显示中;
		}
	}
	get 当前图标实例() {
		return this.UI控制器.地图图标字典表[this.当前图标名];
	}
	//从临时图标池里根据图标名获得一个未显示的临时图标。如果没有，则创建一个新的临时图标加入图标池。
	获取临时图标(图标名) {
		let that = this;
		let 临时图标列表 = that.UI控制器.临时图标池[图标名];
		for (let 候选临时图标实例 of 临时图标列表) {
			if (!候选临时图标实例.visible) {
				return 候选临时图标实例;
			}
		}
		//所有的临时图标都在显示状态中，创建一个新临时图标并导入stage
		let 临时图标实例 = new lib[图标名]();
		临时图标实例.visible = false;
		临时图标列表.push(临时图标实例);
		stage.addChild(临时图标实例);
		stage.setChildIndex(临时图标实例, stage.getChildIndex(全局.临时图标存根));
	}
}
角色.角色uid与角色UI控制器映射集 = new Map();
//剧情角色花名册是一张 角色剧情名 : uid 的对应表。
//比如游戏里可以生成多个上等兵，但是其中一个上等兵有剧情，我们可以给这个上等兵在剧情中起名为"剧情上等兵1"
角色.剧情角色花名册 = {};
角色.创建 = function(角色类型, 角色剧情名){
	let 角色实例 = new 角色(角色类型);
	let 角色UI控制器实例 = new 角色UI控制器(角色实例);
	角色.角色uid与角色UI控制器映射集.set(角色实例.uid, 角色UI控制器实例);
	全局.存档体.角色uid集合.add(角色实例.uid);
	if(arguments.length > 1){
		角色.剧情角色花名册[角色剧情名] = 角色实例.uid;
	}
	return 角色实例.uid;
}
角色.创建并导入地图 = function(地图标识, 角色类型, 角色剧情名){
	let 地图实例 = cls.地图.获取实例(地图标识);
	var 角色uid;
	if(arguments.length > 2) {
		角色uid = 角色.创建(角色类型, 角色剧情名);
	}
	else {
		角色uid = 角色.创建(角色类型);
	}
	地图实例.导入角色UI(角色uid);
	return 角色uid;
}
角色.获取实例 = function(角色标识) {
	//角色标识有两可能，其一是number类型的uid，其二是string类型的角色剧情名，其三是我自己已经是角色实例了
	//为什么要有其三，因为有很多根据输入角色标识不同来获取实例的函数，如果每次输入一个实例都要额外判定太耗时间了
	//所以获取实例允许输入就是一个实例，输出我自己
	if(typeof 角色标识 === 'number'){
		return UID.获取实例(角色标识);
	}
	else if(typeof 角色标识 === 'string'){
		return UID.获取实例(角色.剧情角色花名册[角色标识]);
	}
	else {
		return 角色标识;
	}
}

cls.角色 = 角色;
}());
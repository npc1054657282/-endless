//势力的含义是操作权，当回合切换时，操作权将切换。
//不同的势力相当于不同的玩家，每个势力都有各自的可操作角色
//要注意的是，一个角色可能同时被多个势力操控，例如无意识的机械角色可能同时被多个势力利用。
//因此判定一个势力能操控的角色主要是通过检查各角色的权限码是否包括该势力。
//当然权限码并不只表示势力，毕竟这个东西本来是控制通路的。
//但在这里，一个势力是和权限的一个码位直接对应的，
//势力名与其对应的权限码位名完全相同，一般来讲和一个权限标签名也对应，不过这里没有对相应的权限标签作规定。
//有的势力是AI而有的势力是玩家。对于玩家，势力除了权限码没有什么特别要保存的东西
//未来如果有势力技能的话当然会增加新东西
//但对于AI则不一样，操作请求API是断断续续的，但是AI的操作思维是连贯的，为了让AI在操作时有记忆，需要保存很多东西
//此外对于一些剧情上的AI，会需要一些特殊的信息来保存。有些AI甚至有特殊的操作请求结算方式。
//这些东西都需要一个对象来保存。
(function(){

class 势力 {
    constructor(势力名, 玩家性 = false) {
        let that = this;
        that.uid = UID.分配(that);
        that.势力名 = 势力名;
        that.玩家性 = 玩家性;
    }
    get 势力权限码() {
        return 2n << (cls.权限.权限码位大图鉴[势力名]);
    }
}
//可能应该搞一个势力名到
势力.获取实例 = function(势力标识) {
    if (typeof 势力标识 === "bigint") {
		return UID.获取实例(势力标识);
	}
	else {
		return 势力标识;
	}
}
cls.势力 = 势力;
}());

//来做一个道具作用范围抽象
function 道具作用范围抽象(){
    var that = this;
	//道具作用范围有多种模板模式的选择UI范式。
	//1.单模板模式，直接进入唯一的模板选项UI
	//2.四方向模板模式，有4个模板，每个模板对应一个方向。攻击者周围四格有方向按钮，按下后进入对应模板选项UI
	//3.四方向单选项模板模式，有4个模板，每个模板对应一个方向，且每个模板内只有一个选项，因此按下方向按钮直接选择该选项，不用进入模板选项UI。
	//4.对话框多模板模式，有多个模板，先弹出对话框选择模板，然后进入对应模板选项
	that.道具作用范围模板选择模式 = "单模板模式";
    that.道具作用范围模板数组 = [];
}
//一个道具作用范围可能有多种模板，例如1*3的攻击和3*1的攻击，选定模式是不一样的
function 道具作用范围模板(){
	var that = this;
	that.攻击中心偏移相对性 = "相对";//有相对和绝对两种选项，表示攻击中心像素偏移是相对攻击者还是整个地图
	that.各攻击中心像素偏移数组 = [];
	//示例:这是一个拥有以周围四格为攻击中心的作用范围
	//[{dx:-32,dy:0},{dx:0,dy:-32},{dx:32,dy:0},{dx:0,dy:32}]
	//实际使用时，获得攻击中心为：
	//for 偏移量 in that.各攻击中心相对攻击者像素偏移数组{
	//	var 攻击中心 = 攻击者.clone().offset(偏移量.dx, 偏移量.dy);
	that.各受攻击格中心相对攻击中心像素偏移数组 = [];
	//示例：这是一个只攻击一个格子，格子就在攻击中心的作用范围
	//[{dx:0,dy:0}]
	that.鼠标选定矩形halfx = 16;
	that.鼠标选定矩形halfy = 16;
	//这个东西以各个攻击中心为中点，从攻击中心-halfx~攻击中心+halfx，攻击中心-halfy~攻击中心+halfy
	//构成一个矩形，如果鼠标落在一个攻击中心构成的矩形内，就认为选中了这片攻击格。
	//halfx和halfy是可以根据其他方式算出来的。x和y皆根据以下方法计算
	//候选值1：在各攻击中心像素偏移数组中，对所有偏移的x值（y值）进行排序，然后算出前后两个之间的差值，选取差值最小的并减半。
	//候选值2：在各受攻击格中心相对攻击中心像素偏移数组中，选择其中偏移x值（y值）绝对值最大的再加上16
	//在候选值1和候选值2中，选择较小的那个
}


//关于道具作用范围的一些新概念笔记
//道具的作用范围还是和移动是不同的。移动有寻路问题，而道具则有弹道问题。
//移动寻路遇到障碍时，因为可以绕道，所以会遇到特殊的寻路问题。
//对于不同的道具，可能会受不同的障碍物影响。
//有的道具穿透性强，不论是根据距离打单点，还是有花式范围，都不用操心。
//但对于穿透性差的武器，要考虑障碍物问题。而这里的障碍物不能套用移动时的寻路问题，而是要采用另一套机制。
//老实说，这套机制比寻路问题要简单，就是在作用范围基础上增加一个障碍物判定。
//这个障碍物判定还挺难搞的，因为理论上是需要对起点和终点作直线，然后判断直线经过了哪些格点。
//然后这些直线经过的格点进行障碍物分析，如果武器的权限无法满足弹道门禁则该格判定为障碍物，无法到达指定目标。
//但是非常幸运的是，和寻路问题不同，对于两个格子，直线经过的格点是恒定不变的，不会随着地图版本而变化。
//所以最复杂的部分可以直接通过一张静态表来实现，不需要动态计算。
//当然，静态表还是太大了，所以实际还是考虑用懒加载的方式加载缓存。
//但还是比要一直刷新的寻路问题来得简单。
//而且这个机制只要对起点和每个格点目标做一次判定决定该格点目标能不能炸到就行了
//所以不管啥花式范围都能做，只要最后对范围涉及的各个格点做一次判定就行了。
//当然，如果更严谨的话，对起点和攻击中心作直线可能更合理。不过攻击中心可能不在格点，那可能性就多了。
//我觉得对每个格子做一次判定严谨性已经差不多够了。
//当然实际上花式范围的武器也有不同的情况，有的是子弹很大，所以攻击范围大。这种情况更适合攻击中心。
//有的花式范围是因为武器弹道密集，这种情况就适合每个格子分开判定。
//我觉得没必要再这么细分了，差不多得了。